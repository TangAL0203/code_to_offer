八大排序算法的 Python 实现：http://python.jobbole.com/82270/
1、插入排序
2、希尔排序
3、冒泡排序
4、快速排序
5、直接选择排序
6、堆排序
7、归并排序
8、基数排序


关于排序的知识点

算法稳定性：待排序表中，两个元素关键值相同，如果排序后这两个元素相对位置不变，那么该排序算法就是稳定的，否则就不稳定。(找到实例能说明不稳定即可)

内部排序：排序期间元素全部放在内存中。
外部排序：排序期间元素不能全部放在内存中，需要借助外存(磁盘)。

时间复杂度：通常由比较和移动的次数来决定。
空间复杂度：

1. 插入排序

基本思想：每次将一个待排序的记录，按照其关键字的大小插入到前面已经排好序的子序列中，直到全部记录插入完成。

1.1 普通插入排序
将待排序表划分为三部分，[有序序列，待排序的元素，无序序列]，L[1...i-1] L(i) L[i+1...n]。
每步将一个待排序的纪录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。（每次将value与前一个元素做比较，若value比前一个元素小，则将前一个元素往后移，value往前移）
step1. 从第一个元素开始，该元素可以认为已经被排序
step2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
step3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
step4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
step5. 将新元素插入到该位置后
step6. 重复步骤2~5

代码：OrdinaryInsertionSort.py

时间复杂度：O(n^2)。
空间复杂度：使用了常数个辅助单元，为O(1)
平均复杂度：(最大时间复杂度+最小时间复杂度)/2

1.2 折半(二分)插入排序

在将一个新元素插入已排好序的数组的过程中，寻找插入点时，将待插入区域的首元素设置为a[low]，末元素设置为a[high]，则轮比较时将待插入元素与a[m]，其中m=(low+high)/2相比较,如果比参考元素小，则选择a[low]到a[m-1]为新的插入区域(即high=m-1)，否则选择a[m+1]到a[high]为新的插入区域（即low=m+1），如此直至low<=high不成立，这个时候插入的合适位置就找到了，然后在该位置上插入a[i]，其余数据往后移动一个位置。即将此位置之后所有元素后移一位，并将新元素插入a[high+1]。

代码：BinaryInsertSort.py

时间复杂度：折半查找只是减少了比较次数，但是元素的移动次数不变，所以时间复杂度为O(n^2)
空间复杂度：使用了常数个辅助单元，为O(1)


1.3 希尔排序
希尔排序(Shell Sort)是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因DL．Shell于1959年提出而得名。 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。分组间隔刚开始为数组长度的一般，每次依次缩小为原来的一半，直至减少为1终止。

代码：ShellSort.py


2. 交换排序

基本思想：所谓交换，就是根据序列中两个记录键值的比较结果来对换这两个记录在序列中的位置，交换排序的特点是：将键值较大的记录向序列的尾部移动，键值较小的记录向序列的前部移动。

2.1 冒泡排序

冒泡排序算法的运作如下：（从后往前）
step1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
step2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
step3. 针对所有的元素重复以上的步骤，除了最后一个。
step4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

代码：BubbleSort.py

时间复杂度：比较次数：n(n-1)/2 移动次数：3n(n-1)/2 一次比较需要进行三次移动。
空间复杂度：O(1)

2.2 快速排序

通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。
注：快排是递归的，需要借助一个递归工作栈来保存每一层递归调用的必要信息，其容量与递归调用的最大深度一致。

代码：quickSort.py

时间复杂度：快排是所有内部排序算法中，平均性能最优的排序算法。
空间复杂度：平均：O(log2n) 最坏：O(n) 最好：O(log2n)
提高快排的性能：每次选取枢轴元素尽量选取可以将数据中分的元素，比如从序列的头部和尾部以及中间选取三个元素，再选取三个元素的中间值作为最终的枢轴元素进行划分，或者随机从当前表中选取枢轴元素。

3. 选择排序

选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素(更新的是最小或最大元素的位置)，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法（比如序列[5， 5， 3]第一次就将第一个[5]与[3]交换，导致第一个5挪动到第二个5后面）。

3.1 简单选择排序-----不稳定 
基本思想：第1趟，在待排序记录r1 ~ r[n]中选出最小的记录，将它与r1交换；第2趟，在待排序记录r2 ~ r[n]中选出最小的记录，将它与r2交换；以此类推，第i趟在待排序记录r[i] ~ r[n]中选出最小的记录，将它与r[i]交换，使有序序列不断增长直到全部排序完毕。

代码：SimpleSelectionSort.py

3.2 堆排序(每次取出堆顶元素，将剩下的元素重新调整为大根堆或者小根堆)-----不稳定

完全二叉树(Complete Binary Tree)的定义：若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。

完全二叉树存储为数组形式，n个结点的完全二叉树，最后一个节点时第[n/2]个结点为根结点的孩子。

堆分为最大堆(大根堆)和最小堆(小根堆)，其实就是完全二叉树。最大堆要求节点的元素都要不小于其孩子，最小堆要求节点元素都不大于其左右孩子，两者对左右孩子的大小关系不做任何要求。

堆排序-升序-基本思想(大顶堆)：https://www.cnblogs.com/0zcl/p/6737944.html
step1. 将初始待排序关键字序列(R1,R2....Rn)构建成大顶堆，此堆为初始的无序区
step2. 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,......Rn-1)和新的有序区(Rn)
step3. 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,......Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2....Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。整个过程的核心就是先初始化大顶堆，将最大数(堆顶)的放到堆的最后一个, 堆长度-1, 继续调整成大顶堆，直至堆长度为1，这时，有序序列长度为len(array_list)-1。

代码：HeapSort.py

时间复杂度：O(1)
空间复杂度：O(nlog2n)


4. 归并排序-----稳定

归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。二路归并，即nx1 -> (n/2)x2 -> (n/4)x4 -> (n/8)x8 ... -> (n/n)xn 前者代表子集的个数，后者代表子集中元素的个数。

归并过程为：比较a[i]和a[j]的大小，若a[i]≤a[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；否则将第二个有序表中的元素a[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。

时间复杂度：每一趟归并的时间复杂度为o(n)，总共要进行log2n趟归并，因此总的时间复杂度为o(nlog2n)
空间复杂度：需要用到辅助数组，刚好占用n个单元，因此空间复杂度为o(n)

5. 基数排序-----稳定

基数排序是基于关键字各位的大小进行排序的，不是基于关键字的比较进行的。

基数：十进制数基数就是10，用r表示，代表队列的个数。
d元组：将数组中元素用d元组表示，就是d位表示。总共比较d次，每次按照某一个位来给队列添加元素，然后将队列进行收尾相加。

基数排序分为最高位优先(MSD)和最低位优先(LSD)

时间复杂度：O(d(n+r))
空间复杂：O(r) 需要r个队列，r个队列中存放n个元素。（个人感觉空间复杂度为O(n)）







	

